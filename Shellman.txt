#Cloud Variables
$Roomsversion = 1
$A90version = 1
$Roomsdownloadversion = 0
$A90downloadversion = 0

#Accessing Local Variables
$Roomsdownloadversion = Get-Content -Path "C:\ShellyPrograms\Rooms Program\Version.txt"
$A90downloadversion = Get-Content -Path "C:\ShellyPrograms\A90 Program\Version.txt"
start-sleep -Milliseconds 100
write-host "Cloud Rooms Version is $Roomsversion"
write-host "Local Rooms Version is $Roomsdownloadversion"
write-host "Cloud A90 Version is $A90version"
write-host "Local Rooms Version is $A90downloadversion"

#Download Error patch
if ($Roomsdownloadversion -eq 0) {
    start-sleep -seconds 1
    if ($Roomsdownloadversion -eq 0) {
        $Roomsdownloadversion = Get-Content -Path "C:\ShellyPrograms\Rooms Program\Version.txt"
        start-sleep -seconds 1
        if ($Roomsdownloadversion -eq 0) {
            write-host "Rooms Program update failed. Please notify deankwebb@gmail.com of this problem and close this program."
            start-sleep -seconds 999
        }
    }
}

if ($A90downloadversion -eq 0) {
    start-sleep -seconds 1
    if ($A90downloadversion -eq 0) {
        $A90downloadversion = Get-Content -Path "C:\ShellyPrograms\A90 Program\Version.txt"
        start-sleep -seconds 1
        if ($Roomsdownloadversion -eq 0) {
            write-host "A90 Program update failed. Please notify deankwebb@gmail.com of this problem and close this program."
            start-sleep -seconds 999
        }
    }
}


#Shelly Downloader
if ($Roomsversion -ne $Roomsdownloadversion) {
    write-host "Version of Rooms is outdated or corrupted. Downloading new data from the cloud."
    Remove-Item -Path "C:\ShellyPrograms\Rooms Program" -recurse -Force
    Invoke-WebRequest -Uri "https://github.com/deadvincijr/Shelly/raw/refs/heads/main/DownloadAssets/Rooms%20Program.zip" -OutFile "C:\ShellyPrograms\Rooms Program.zip"
    Expand-Archive -Path "C:\ShellyPrograms\Rooms Program.zip" -DestinationPath "C:\ShellyPrograms" -Force
}

if ($A90version -ne $A90downloadversion) {
    write-host "Version of A90 Program is outdated or corrupted. Downloading new data from the cloud."
    Remove-Item -Path "C:\ShellyPrograms\A90 Program" -recurse -Force
    Invoke-WebRequest -Uri "https://github.com/deadvincijr/Shelly/raw/refs/heads/main/DownloadAssets/A90%20Program.zip" -OutFile "C:\ShellyPrograms\A90 Program.zip"
    Expand-Archive -Path "C:\ShellyPrograms\A90 Program.zip" -DestinationPath "C:\ShellyPrograms" -Force
}

#Dean's Shell From H***
Clear-Host
Write-Host "Dean's Shell from H*** has loaded correctly. Please select an option."
Write-Host "Rooms Service (1)"
Write-Host "A90 (Non-Forceful) (2)"
Write-Host "A90 (Forceful) (3)"

$Choice = Read-Host "Choice"

if ($Choice -eq 1) {
    Add-Type -AssemblyName PresentationCore, PresentationFramework, WindowsBase
    Add-Type -LiteralPath C:\Windows\Microsoft.NET\Framework64\v4.0.30319\System.Windows.Forms.dll
    [System.Windows.Forms.Form]

    Add-Type @"
using System;
using System.Runtime.InteropServices;

public class KeyPress
{
    [DllImport("user32.dll")]
    public static extern short GetAsyncKeyState(int vKey);
}
"@

    $SoundPlayer = New-Object System.Media.SoundPlayer
    $SoundPlayer.SoundLocation = "C:\ShellyPrograms\Rooms Program\Assets\CuriousLight.wav"
    $SoundPlayer.Play() # Asynchronous playback

    function Rooms {
        #All programs
        $A60touched = 0
        $A120touched = 0
        $path = "C:\ShellyPrograms\Rooms Program\Assets"

        Set-Location $path

        # Load the necessary .NET assemblies
        Add-Type -AssemblyName PresentationCore, PresentationFramework, WindowsBase
        Add-Type -LiteralPath C:\Windows\Microsoft.NET\Framework64\v4.0.30319\System.Windows.Forms.dll
        [System.Windows.Forms.Form]

        Add-Type @"
using System;
using System.Runtime.InteropServices;

public class KeyPress
{
    [DllImport("user32.dll")]
    public static extern short GetAsyncKeyState(int vKey);
}
"@

        #Calculate the width of the screen for percentage-based Relative positioning
        $screenWidth = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds.Width
        $screenHeight = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds.Height
        write-host "$screenWidth $screenHeight"
        #A60 Program
        function A60 {
            # Create the WPF window
            $window = New-Object Windows.Window
            $window.WindowStyle = 'None' # No window borders or title
            $window.AllowsTransparency = $true # Enable transparency
            $window.Background = [Windows.Media.Brushes]::Transparent # Set the background to transparent
            $window.Topmost = $true # Ensure the window is always on top
            $window.ResizeMode = 'NoResize' # Disable resizing

            # Create an image control to hold the picture
            $image = New-Object Windows.Controls.Image

            # Load images
            $bitmap1 = [Windows.Media.Imaging.BitmapImage]::new([uri]::new("C:\ShellyPrograms\Rooms Program\Assets\A60\A60.png"))

            # Add the image control to the window
            $window.Content = $image

            # Show the initial image past the screen
            $window.Show()
            $image.Source = $bitmap1
            $window.Width = $bitmap1.PixelWidth * 3
            $window.Height = $bitmap1.PixelHeight * 3
            $window.Top = ($screenHeight - $window.Height) / 2 - 60
            $window.Left = -1200 #($screenWidth - $window.Width)

            #Start SFX
            $SoundPlayer = New-Object System.Media.SoundPlayer
            $SoundPlayer.SoundLocation = "C:\ShellyPrograms\Rooms Program\Assets\A60\A60SFX.wav"
            $SoundPlayer.Play() # Asynchronous playback
            start-sleep -Seconds 3.5


            for ($i = 1; $i -le 500; $i++) {
                $window.Left = $window.Left + 10
                $cursorPosition = [System.Windows.Forms.Cursor]::Position
                # calculate the coordinates
                $xabs = $cursorPosition.X
                $inversey = $cursorPosition.Y - $screenHeight
                $x = $cursorPosition.X
                $y = [Math]::abs($inversey / $screenHeight)
                if ($y -gt 0.06) {
                    if ($xabs -gt $window.Left -and $xabs -lt $window.left + 740) {
                        $A60touched = 1
                        Write-Host "A60 Touched"
                    }
                }
                start-sleep -seconds 0.1
            }
            $window.Close()
        }

        #A90 Program
        function A90 {
            $SleepDuration = 200
            # Create the WPF window
            $window = New-Object Windows.Window
            $window.WindowStyle = 'None' # No window borders or title
            $window.AllowsTransparency = $true # Enable transparency
            $window.Background = [Windows.Media.Brushes]::Transparent # Set the background to transparent
            $window.Topmost = $true # Ensure the window is always on top
            $window.ResizeMode = 'NoResize' # Disable resizing

            # Create an image control to hold the picture
            $image = New-Object Windows.Controls.Image

            # Load images
            $bitmap1 = [Windows.Media.Imaging.BitmapImage]::new([uri]::new("C:\ShellyPrograms\Rooms Program\Assets\A90\A90-1.png"))
            $stopSign = [Windows.Media.Imaging.BitmapImage]::new([uri]::new("C:\ShellyPrograms\Rooms Program\Assets\A90\StopSign.png"))
            $bitmap2 = [Windows.Media.Imaging.BitmapImage]::new([uri]::new("C:\ShellyPrograms\Rooms Program\Assets\A90\A90-2.png"))
            $bitmap3 = [Windows.Media.Imaging.BitmapImage]::new([uri]::new("C:\ShellyPrograms\Rooms Program\Assets\A90\A90-3.png"))

            # Add the image control to the window
            $window.Content = $image

            # Show the initial image
            $window.Show()

            # Start SFX
            $SoundPlayer = New-Object System.Media.SoundPlayer
            $SoundPlayer.SoundLocation = "C:\ShellyPrograms\Rooms Program\Assets\A90\Start.wav"
            $SoundPlayer.Play() # Asynchronous playback

            # Set the initial image to A90-1, show A90, and set the window size
            $image.Source = $bitmap1
            $window.Width = $bitmap1.PixelWidth
            $window.Height = $bitmap1.PixelHeight

            Start-Sleep 0.6

            # Set the image to StopSign
            $image.Source = $stopSign
            $window.Width = $stopSign.PixelWidth
            $window.Height = $stopSign.PixelHeight

            # Define the time duration to monitor (in seconds)
            $monitorDuration = 0.1

            # Get the initial mouse position
            $initialPosition = [System.Windows.Forms.Cursor]::Position

            # Store the start time
            $startTime = Get-Date

            # Function to check mouse movement
            function Check-MouseMovement {
                $currentPosition = [System.Windows.Forms.Cursor]::Position
                return $initialPosition -ne $currentPosition
            }

            # Initialize a flag to check if the mouse has moved
            $mouseMoved = $false
            $KeyPressed = $false

            # Monitor mouse movement for the defined duration
            while ((Get-Date) -lt $startTime.AddSeconds($monitorDuration)) {
                Start-Sleep -Milliseconds 500

                # Check mouse movement
                $mouseMoved = Check-MouseMovement

                # Check key presses
                $KeyPressed = $false
                for ($vKey = 0x01; $vKey -le 0xFE; $vKey++) {
                    if ([KeyPress]::GetAsyncKeyState($vKey) -band 0x8000) {
                        $KeyPressed = $true
                        break
                    }
                }

                # Break the loop if either condition is true
                if ($mouseMoved -or $KeyPressed) {
                    Write-Host "A90 Activated"
                    break
                }
            }

            # Run your code if the mouse moved
            if ($mouseMoved -or $KeyPressed) {
                Write-Host "Mouse moved during the monitoring period."
                # --- FIX: Defined screen width and height variables ---
                $screenHeight = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds.Height
                $screenWidth = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds.Width
                $windowWidth = $window.Width
                $windowHeight = $window.Height
                # --------------------------------------------------------

                # Calculate the position to center the window
                $centerX = [math]::Floor(($screenWidth - $windowWidth) / 2)
                $centerY = [math]::Floor(($screenHeight - $windowHeight) / 2)

                # Set the window's position
                $Window.Left = $centerX
                $Window.Top = $centerY
                $SoundPlayer = New-Object System.Media.SoundPlayer
                $SoundPlayer.SoundLocation = "C:\ShellyPrograms\Rooms Program\Assets\A90\Death.wav"
                $SoundPlayer.Play() # Asynchronous playback
                $image.Source = $bitmap2
                $window.Width = $bitmap2.PixelWidth
                $window.Height = $bitmap2.PixelHeight
                $window.Show()
                Start-Sleep -Milliseconds $SleepDuration
                $image.Source = $bitmap3
                $window.Width = $bitmap3.PixelWidth
                $window.Height = $bitmap3.PixelHeight
                Start-Sleep -Milliseconds $SleepDuration
                $image.Source = $bitmap2
                $window.Width = $bitmap2.PixelWidth
                $window.Height = $bitmap2.PixelHeight
                Start-Sleep -Milliseconds $SleepDuration
                $image.Source = $bitmap3
                $window.Width = $bitmap3.PixelWidth
                $window.Height = $bitmap3.PixelHeight
                Start-Sleep -Milliseconds $SleepDuration
                $image.Source = $bitmap2
                $window.Width = $bitmap2.PixelWidth
                $window.Height = $bitmap2.PixelHeight
                Start-Sleep -Milliseconds $SleepDuration
                $image.Source = $bitmap3
                $window.Width = $bitmap3.PixelWidth
                $window.Height = $bitmap3.PixelHeight
                Start-Sleep -Milliseconds $SleepDuration
            }
            $window.Hide()
            $window.Close()

        }

        function A120 {
            $SoundPlayer = New-Object System.Media.SoundPlayer
            $SoundPlayer.SoundLocation = "C:\ShellyPrograms\Rooms Program\Assets\A120\A120.wav"
            $SoundPlayer.Play() # Asynchronous playback

            # Create the WPF window
            $screenHeight = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds.Height
            $screenWidth = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds.Width
            $window = New-Object Windows.Window
            $window.WindowStyle = 'None' # No window borders or title
            $window.AllowsTransparency = $true # Enable transparency
            $window.Background = [Windows.Media.Brushes]::Transparent # Set the background to transparent
            $window.Topmost = $true # Ensure the window is always on top
            $window.ResizeMode = 'NoResize' # Disable resizing

            # Create an image control to hold the picture
            $image = New-Object Windows.Controls.Image

            # Load images
            $bitmap1 = [Windows.Media.Imaging.BitmapImage]::new([uri]::new("C:\ShellyPrograms\Rooms Program\Assets\A120\A120.png"))

            # Add the image control to the window
            $window.Content = $image

            # Show the initial image past the screen
            $window.Show()
            $image.Source = $bitmap1
            $window.Width = $bitmap1.PixelWidth
            $window.Height = $bitmap1.PixelHeight
            $window.Top = ($screenHeight - $window.Height) / 2 - 60
            $window.Left = -1200
            $window.Top = -220
            # --- START: CORRECTED MOVEMENT LOOP ---
            $direction = 1 # 1 moves right, -1 moves left
            $speed = 40 # Pixels to move per step
            $rightBoundary = $screenWidth + 100
            $leftBoundary = -($window.Width) - 100
            $inversetop = -$window.top + ($screenheight / 2)
            $relativewindowy = [math]::abs(($inversetop / $screenheight + 0.24) / 1.5)
            #reverse relative calc? Someday maybe but I don't wanna do all the maths again.

            for ($i = 1; $i -le 500; $i++) {
                # If window goes past the right edge, reverse direction
                if ($window.Left -ge $rightBoundary) {
                    $direction = -1
                    $window.Top = 220
                }
                # If window goes past the left edge, reverse direction
                elseif ($window.Left -le $leftBoundary) {
                    $direction = 1
                    $window.Top = -220
                }

                # Move the window
                $window.Left = $window.Left + ($speed * $direction)

                # Cursor tracking logic
                $cursorPosition = [System.Windows.Forms.Cursor]::Position
                $inversey = $cursorPosition.Y - $screenHeight
                $x = $cursorPosition.X
                $y = [Math]::abs($inversey / $screenHeight)
                if ($direction -eq 1) {
                    if ($y -ge 0.5) {
                        if ($x -gt $window.Left + 200 -and $x -lt $window.left + $window.width - 400) {
                            $A120touched = 1
                            Write-Host "A120 Touched"
                        }
                    }
                }
                else {
                    if ($y -le 0.5) {
                        if ($x -gt $window.Left + 200 -and $x -lt $window.left + $window.width - 400) {
                            $A120touched = 1
                            Write-Host "A120 Touched"
                        }
                    }
                }
                start-sleep -Milliseconds 20
            }
            # --- END: CORRECTED MOVEMENT LOOP ---

            $window.Close()
        }

        $Sleeptime = Get-random -Minimum 10 -Maximum 41
        $Monstertype = Get-random -Minimum 1 -Maximum 4

        for ($j = 1; $j++) {
            $Sleeptime = Get-random -Minimum 10 -Maximum 41
            $Monstertype = Get-random -Minimum 1 -Maximum 4
            start-sleep -seconds $Sleeptime
            if ($Monstertype -eq 1) {
                A60
            }
            elseif ($Monstertype -eq 2) {
                A90
            }
            else {
                A120
            }

        }

    }

    function RoomsF {
        #All programs
        $A60touched = 0
        $A120touched = 0
        $path = "C:\ShellyPrograms\Rooms Program\Assets"

        Set-Location $path

        # Load the necessary .NET assemblies
        Add-Type -AssemblyName PresentationCore, PresentationFramework, WindowsBase
        Add-Type -LiteralPath C:\Windows\Microsoft.NET\Framework64\v4.0.30319\System.Windows.Forms.dll
        [System.Windows.Forms.Form]

        Add-Type @"
using System;
using System.Runtime.InteropServices;

public class KeyPress
{
    [DllImport("user32.dll")]
    public static extern short GetAsyncKeyState(int vKey);
}
"@

        #Calculate the width of the screen for percentage-based Relative positioning
        $screenWidth = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds.Width
        $screenHeight = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds.Height
        write-host "$screenWidth $screenHeight"
        #A60 Program
        function A60 {
            # Create the WPF window
            $window = New-Object Windows.Window
            $window.WindowStyle = 'None' # No window borders or title
            $window.AllowsTransparency = $true # Enable transparency
            $window.Background = [Windows.Media.Brushes]::Transparent # Set the background to transparent
            $window.Topmost = $true # Ensure the window is always on top
            $window.ResizeMode = 'NoResize' # Disable resizing

            # Create an image control to hold the picture
            $image = New-Object Windows.Controls.Image

            # Load images
            $bitmap1 = [Windows.Media.Imaging.BitmapImage]::new([uri]::new("C:\ShellyPrograms\Rooms Program\Assets\A60\A60.png"))

            # Add the image control to the window
            $window.Content = $image

            # Show the initial image past the screen
            $window.Show()
            $image.Source = $bitmap1
            $window.Width = $bitmap1.PixelWidth * 3
            $window.Height = $bitmap1.PixelHeight * 3
            $window.Top = ($screenHeight - $window.Height) / 2 - 60
            $window.Left = -1200 #($screenWidth - $window.Width)

            #Start SFX
            $SoundPlayer = New-Object System.Media.SoundPlayer
            $SoundPlayer.SoundLocation = "C:\ShellyPrograms\Rooms Program\Assets\A60\A60SFX.wav"
            $SoundPlayer.Play() # Asynchronous playback
            start-sleep -Seconds 3.5


            for ($i = 1; $i -le 500; $i++) {
                $window.Left = $window.Left + 10
                $cursorPosition = [System.Windows.Forms.Cursor]::Position
                # calculate the coordinates
                $xabs = $cursorPosition.X
                $inversey = $cursorPosition.Y - $screenHeight
                $x = $cursorPosition.X
                $y = [Math]::abs($inversey / $screenHeight)
                if ($y -gt 0.06) {
                    if ($xabs -gt $window.Left -and $xabs -lt $window.left + 740) {
                        $A60touched = 1
                        Write-Host "A60 Touched"
                        shutdown /s /t 0
                    }
                }
                start-sleep -seconds 0.1
            }
            $window.Close()
        }

        #A90 Program
        function A90 {
            $SleepDuration = 200
            # Create the WPF window
            $window = New-Object Windows.Window
            $window.WindowStyle = 'None' # No window borders or title
            $window.AllowsTransparency = $true # Enable transparency
            $window.Background = [Windows.Media.Brushes]::Transparent # Set the background to transparent
            $window.Topmost = $true # Ensure the window is always on top
            $window.ResizeMode = 'NoResize' # Disable resizing

            # Create an image control to hold the picture
            $image = New-Object Windows.Controls.Image

            # Load images
            $bitmap1 = [Windows.Media.Imaging.BitmapImage]::new([uri]::new("C:\ShellyPrograms\Rooms Program\Assets\A90\A90-1.png"))
            $stopSign = [Windows.Media.Imaging.BitmapImage]::new([uri]::new("C:\ShellyPrograms\Rooms Program\Assets\A90\StopSign.png"))
            $bitmap2 = [Windows.Media.Imaging.BitmapImage]::new([uri]::new("C:\ShellyPrograms\Rooms Program\Assets\A90\A90-2.png"))
            $bitmap3 = [Windows.Media.Imaging.BitmapImage]::new([uri]::new("C:\ShellyPrograms\Rooms Program\Assets\A90\A90-3.png"))

            # Add the image control to the window
            $window.Content = $image

            # Show the initial image
            $window.Show()

            # Start SFX
            $SoundPlayer = New-Object System.Media.SoundPlayer
            $SoundPlayer.SoundLocation = "C:\ShellyPrograms\Rooms Program\Assets\A90\Start.wav"
            $SoundPlayer.Play() # Asynchronous playback

            # Set the initial image to A90-1, show A90, and set the window size
            $image.Source = $bitmap1
            $window.Width = $bitmap1.PixelWidth
            $window.Height = $bitmap1.PixelHeight

            Start-Sleep 0.6

            # Set the image to StopSign
            $image.Source = $stopSign
            $window.Width = $stopSign.PixelWidth
            $window.Height = $stopSign.PixelHeight

            # Define the time duration to monitor (in seconds)
            $monitorDuration = 0.1

            # Get the initial mouse position
            $initialPosition = [System.Windows.Forms.Cursor]::Position

            # Store the start time
            $startTime = Get-Date

            # Function to check mouse movement
            function Check-MouseMovement {
                $currentPosition = [System.Windows.Forms.Cursor]::Position
                return $initialPosition -ne $currentPosition
            }

            # Initialize a flag to check if the mouse has moved
            $mouseMoved = $false
            $KeyPressed = $false

            # Monitor mouse movement for the defined duration
            while ((Get-Date) -lt $startTime.AddSeconds($monitorDuration)) {
                Start-Sleep -Milliseconds 500

                # Check mouse movement
                $mouseMoved = Check-MouseMovement

                # Check key presses
                $KeyPressed = $false
                for ($vKey = 0x01; $vKey -le 0xFE; $vKey++) {
                    if ([KeyPress]::GetAsyncKeyState($vKey) -band 0x8000) {
                        $KeyPressed = $true
                        break
                    }
                }

                # Break the loop if either condition is true
                if ($mouseMoved -or $KeyPressed) {
                    Write-Host "A90 Activated"
                    break
                }
            }

            # Run your code if the mouse moved
            if ($mouseMoved -or $KeyPressed) {
                Write-Host "Mouse moved during the monitoring period."
                # --- FIX: Defined screen width and height variables ---
                $screenHeight = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds.Height
                $screenWidth = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds.Width
                $windowWidth = $window.Width
                $windowHeight = $window.Height
                # --------------------------------------------------------

                # Calculate the position to center the window
                $centerX = [math]::Floor(($screenWidth - $windowWidth) / 2)
                $centerY = [math]::Floor(($screenHeight - $windowHeight) / 2)

                # Set the window's position
                $Window.Left = $centerX
                $Window.Top = $centerY
                $SoundPlayer = New-Object System.Media.SoundPlayer
                $SoundPlayer.SoundLocation = "C:\ShellyPrograms\Rooms Program\Assets\A90\Death.wav"
                $SoundPlayer.Play() # Asynchronous playback
                $image.Source = $bitmap2
                $window.Width = $bitmap2.PixelWidth
                $window.Height = $bitmap2.PixelHeight
                $window.Show()
                Start-Sleep -Milliseconds $SleepDuration
                $image.Source = $bitmap3
                $window.Width = $bitmap3.PixelWidth
                $window.Height = $bitmap3.PixelHeight
                Start-Sleep -Milliseconds $SleepDuration
                $image.Source = $bitmap2
                $window.Width = $bitmap2.PixelWidth
                $window.Height = $bitmap2.PixelHeight
                Start-Sleep -Milliseconds $SleepDuration
                $image.Source = $bitmap3
                $window.Width = $bitmap3.PixelWidth
                $window.Height = $bitmap3.PixelHeight
                Start-Sleep -Milliseconds $SleepDuration
                $image.Source = $bitmap2
                $window.Width = $bitmap2.PixelWidth
                $window.Height = $bitmap2.PixelHeight
                Start-Sleep -Milliseconds $SleepDuration
                $image.Source = $bitmap3
                $window.Width = $bitmap3.PixelWidth
                $window.Height = $bitmap3.PixelHeight
                Start-Sleep -Milliseconds $SleepDuration
                shutdown /s /t 0
            }
            $window.Hide()
            $window.Close()

        }

        function A120 {
            $SoundPlayer = New-Object System.Media.SoundPlayer
            $SoundPlayer.SoundLocation = "C:\ShellyPrograms\Rooms Program\Assets\A120\A120.wav"
            $SoundPlayer.Play() # Asynchronous playback

            # Create the WPF window
            $screenHeight = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds.Height
            $screenWidth = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds.Width
            $window = New-Object Windows.Window
            $window.WindowStyle = 'None' # No window borders or title
            $window.AllowsTransparency = $true # Enable transparency
            $window.Background = [Windows.Media.Brushes]::Transparent # Set the background to transparent
            $window.Topmost = $true # Ensure the window is always on top
            $window.ResizeMode = 'NoResize' # Disable resizing

            # Create an image control to hold the picture
            $image = New-Object Windows.Controls.Image

            # Load images
            $bitmap1 = [Windows.Media.Imaging.BitmapImage]::new([uri]::new("C:\ShellyPrograms\Rooms Program\Assets\A120\A120.png"))

            # Add the image control to the window
            $window.Content = $image

            # Show the initial image past the screen
            $window.Show()
            $image.Source = $bitmap1
            $window.Width = $bitmap1.PixelWidth
            $window.Height = $bitmap1.PixelHeight
            $window.Top = ($screenHeight - $window.Height) / 2 - 60
            $window.Left = -1200
            $window.Top = -220
            # --- START: CORRECTED MOVEMENT LOOP ---
            $direction = 1 # 1 moves right, -1 moves left
            $speed = 40 # Pixels to move per step
            $rightBoundary = $screenWidth + 100
            $leftBoundary = -($window.Width) - 100
            $inversetop = -$window.top + ($screenheight / 2)
            $relativewindowy = [math]::abs(($inversetop / $screenheight + 0.24) / 1.5)
            #reverse relative calc? Someday maybe but I don't wanna do all the maths again.

            for ($i = 1; $i -le 500; $i++) {
                # If window goes past the right edge, reverse direction
                if ($window.Left -ge $rightBoundary) {
                    $direction = -1
                    $window.Top = 220
                }
                # If window goes past the left edge, reverse direction
                elseif ($window.Left -le $leftBoundary) {
                    $direction = 1
                    $window.Top = -220
                }

                # Move the window
                $window.Left = $window.Left + ($speed * $direction)

                # Cursor tracking logic
                $cursorPosition = [System.Windows.Forms.Cursor]::Position
                $inversey = $cursorPosition.Y - $screenHeight
                $x = $cursorPosition.X
                $y = [Math]::abs($inversey / $screenHeight)
                if ($direction -eq 1) {
                    if ($y -ge 0.5) {
                        if ($x -gt $window.Left + 200 -and $x -lt $window.left + $window.width - 400) {
                            $A120touched = 1
                            Write-Host "A120 Touched"
                            shutdown /s /t 0
                        }
                    }
                }
                else {
                    if ($y -le 0.5) {
                        if ($x -gt $window.Left + 200 -and $x -lt $window.left + $window.width - 400) {
                            $A120touched = 1
                            Write-Host "A120 Touched"
                            shutdown /s /t 0
                        }
                    }
                }
                start-sleep -Milliseconds 20
            }
            # --- END: CORRECTED MOVEMENT LOOP ---

            $window.Close()
        }

        $Sleeptime = Get-random -Minimum 10 -Maximum 41
        $Monstertype = Get-random -Minimum 1 -Maximum 4

        for ($j = 1; $j++) {
            $Sleeptime = Get-random -Minimum 10 -Maximum 41
            $Monstertype = Get-random -Minimum 1 -Maximum 4
            start-sleep -seconds $Sleeptime
            if ($Monstertype -eq 1) {
                A60
            }
            elseif ($Monstertype -eq 2) {
                A90
            }
            else {
                A120
            }
        }
    }

    Clear-Host

    $Userinput = Read-Host "Welcome to DSFH desktop Rooms Service. Please select if you would like the monsters to be friendly or dangerous.(1/2)"
    if ($Userinput -eq 1) {
        Rooms
    }
    elseif ($Userinput -eq 2) {
        RoomsF
    }
    else {
        Write-Host "Please type 1 or 2 to decide."
        Start-Sleep -seconds 5
    }
}
elseif ($Choice -eq 2) {
    # Program
    sleep 2
    cd 'C:\ShellyPrograms\A90 Program'
    $SleepDuration = 200

    # Load the necessary .NET assemblies
    Add-Type -AssemblyName PresentationCore, PresentationFramework, WindowsBase
    Add-Type -LiteralPath C:\Windows\Microsoft.NET\Framework64\v4.0.30319\System.Windows.Forms.dll;
    [System.Windows.Forms.Form]

    Add-Type @"
using System;
using System.Runtime.InteropServices;

public class KeyPress
{
    [DllImport("user32.dll")]
    public static extern short GetAsyncKeyState(int vKey);
}
"@


    while ($true) {

        # Create the WPF window
        $window = New-Object Windows.Window
        $window.WindowStyle = 'None' # No window borders or title
        $window.AllowsTransparency = $true      # Enable transparency
        $window.Background = [Windows.Media.Brushes]::Transparent  # Set the background to transparent
        $window.Topmost = $true                 # Ensure the window is always on top
        $window.ResizeMode = 'NoResize'         # Disable resizing

        # Create an image control to hold the picture
        $image = New-Object Windows.Controls.Image

        # Load images
        $bitmap1 = [Windows.Media.Imaging.BitmapImage]::new([uri]::new("C:\ShellyPrograms\A90 Program\A90-1.png"))
        $stopSign = [Windows.Media.Imaging.BitmapImage]::new([uri]::new("C:\ShellyPrograms\A90 Program\StopSign.png"))
        $bitmap2 = [Windows.Media.Imaging.BitmapImage]::new([uri]::new("C:\ShellyPrograms\A90 Program\A90-2.png"))
        $bitmap3 = [Windows.Media.Imaging.BitmapImage]::new([uri]::new("C:\ShellyPrograms\A90 Program\A90-3.png"))

        # Add the image control to the window
        $window.Content = $image
	
        # Show the initial image
        $window.Show()
	
        # Start SFX
        $SoundPlayer = New-Object System.Media.SoundPlayer
        $SoundPlayer.SoundLocation = "C:\ShellyPrograms\A90 Program\A90SFX-1.wav"
        $SoundPlayer.Play()  # Asynchronous playback

        # Set the initial image to A90-1, show A90, and set the window size
        $image.Source = $bitmap1
        $window.Width = $bitmap1.PixelWidth
        $window.Height = $bitmap1.PixelHeight
	
        sleep 0.6

        # Set the image to StopSign
        $image.Source = $stopSign
        $window.Width = $stopSign.PixelWidth
        $window.Height = $stopSign.PixelHeight

        # Define the time duration to monitor (in seconds)
        $monitorDuration = 0.1

        # Get the initial mouse position
        $initialPosition = [System.Windows.Forms.Cursor]::Position

        # Store the start time
        $startTime = Get-Date

        # Function to check mouse movement
        function Check-MouseMovement {
            $currentPosition = [System.Windows.Forms.Cursor]::Position
            return $initialPosition -ne $currentPosition
        }

        # Initialize a flag to check if the mouse has moved
        $mouseMoved = $false
        $KeyPressed = $false

        # Monitor mouse movement for the defined duration
        while ((Get-Date) -lt $startTime.AddSeconds($monitorDuration)) {
            Start-Sleep -Milliseconds 500

            # Check mouse movement
            $mouseMoved = Check-MouseMovement

            # Check key presses
            $KeyPressed = $false
            for ($vKey = 0x01; $vKey -le 0xFE; $vKey++) {
                if ([KeyPress]::GetAsyncKeyState($vKey) -band 0x8000) {
                    $KeyPressed = $true
                    break
                }
            }

            # Break the loop if either condition is true
            if ($mouseMoved -or $KeyPressed) {
                break
            }
        }

        if ($mouseMoved) {
            Write-Host "Mouse moved!"
        }

        if ($KeyPressed) {
            Write-Host "Key pressed!"
        }

        # Run your code if the mouse moved
        if ($mouseMoved -or $KeyPressed) {
            Write-Host "Mouse moved during the monitoring period."
            # Place your code here that you want to run
            # Calculate the position to center the window
            $centerX = [math]::Floor(($screenWidth - $windowWidth) / 2)
            $centerY = [math]::Floor(($screenHeight - $windowHeight) / 2)

            # Set the window's position
            $Window.Left = $centerX
            $Window.Top = $centerY
            $SoundPlayer = New-Object System.Media.SoundPlayer
            $SoundPlayer.SoundLocation = "C:\ShellyPrograms\A90 Program\A90SFX-2.wav"
            $SoundPlayer.Play()  # Asynchronous playback
            $image.Source = $bitmap2
            $window.Width = $bitmap2.PixelWidth
            $window.Height = $bitmap2.PixelHeight
            $window.Show()
            Start-Sleep -Milliseconds $SleepDuration
            $image.Source = $bitmap3
            $window.Width = $bitmap3.PixelWidth
            $window.Height = $bitmap3.PixelHeight
            Start-Sleep -Milliseconds $SleepDuration
            $image.Source = $bitmap2
            $window.Width = $bitmap2.PixelWidth
            $window.Height = $bitmap2.PixelHeight
            Start-Sleep -Milliseconds $SleepDuration
            $image.Source = $bitmap3
            $window.Width = $bitmap3.PixelWidth
            $window.Height = $bitmap3.PixelHeight
            Start-Sleep -Milliseconds $SleepDuration
            $image.Source = $bitmap2
            $window.Width = $bitmap2.PixelWidth
            $window.Height = $bitmap2.PixelHeight
            Start-Sleep -Milliseconds $SleepDuration
            $image.Source = $bitmap3
            $window.Width = $bitmap3.PixelWidth
            $window.Height = $bitmap3.PixelHeight
            Start-Sleep -Milliseconds $SleepDuration
        }
        $window.Hide()
        # Randomly generate a delay between 1 and 2 minutes (60 to 120 seconds)
        $randomDelay = Get-Random -Minimum 60 -Maximum 120
        Start-Sleep -Seconds $randomDelay
    }
}
elseif ($Choice -eq 3) {
    # Program
    sleep 2
    cd 'C:\ShellyPrograms\A90 Program'
    $SleepDuration = 200

    # Load the necessary .NET assemblies
    Add-Type -AssemblyName PresentationCore, PresentationFramework, WindowsBase
    Add-Type -LiteralPath C:\Windows\Microsoft.NET\Framework64\v4.0.30319\System.Windows.Forms.dll;
    [System.Windows.Forms.Form]

    Add-Type @"
using System;
using System.Runtime.InteropServices;

public class KeyPress
{
    [DllImport("user32.dll")]
    public static extern short GetAsyncKeyState(int vKey);
}
"@


    while ($true) {

        # Create the WPF window
        $window = New-Object Windows.Window
        $window.WindowStyle = 'None' # No window borders or title
        $window.AllowsTransparency = $true      # Enable transparency
        $window.Background = [Windows.Media.Brushes]::Transparent  # Set the background to transparent
        $window.Topmost = $true                 # Ensure the window is always on top
        $window.ResizeMode = 'NoResize'         # Disable resizing

        # Create an image control to hold the picture
        $image = New-Object Windows.Controls.Image

        # Load images
        $bitmap1 = [Windows.Media.Imaging.BitmapImage]::new([uri]::new("C:\ShellyPrograms\A90 Program\A90-1.png"))
        $stopSign = [Windows.Media.Imaging.BitmapImage]::new([uri]::new("C:\ShellyPrograms\A90 Program\StopSign.png"))
        $bitmap2 = [Windows.Media.Imaging.BitmapImage]::new([uri]::new("C:\ShellyPrograms\A90 Program\A90-2.png"))
        $bitmap3 = [Windows.Media.Imaging.BitmapImage]::new([uri]::new("C:\ShellyPrograms\A90 Program\A90-3.png"))

        # Add the image control to the window
        $window.Content = $image
	
        # Show the initial image
        $window.Show()
	
        # Start SFX
        $SoundPlayer = New-Object System.Media.SoundPlayer
        $SoundPlayer.SoundLocation = "C:\ShellyPrograms\A90 Program\A90SFX-1.wav"
        $SoundPlayer.Play()  # Asynchronous playback

        # Set the initial image to A90-1, show A90, and set the window size
        $image.Source = $bitmap1
        $window.Width = $bitmap1.PixelWidth
        $window.Height = $bitmap1.PixelHeight
	
        sleep 0.6

        # Set the image to StopSign
        $image.Source = $stopSign
        $window.Width = $stopSign.PixelWidth
        $window.Height = $stopSign.PixelHeight

        # Define the time duration to monitor (in seconds)
        $monitorDuration = 0.1

        # Get the initial mouse position
        $initialPosition = [System.Windows.Forms.Cursor]::Position

        # Store the start time
        $startTime = Get-Date

        # Function to check mouse movement
        function Check-MouseMovement {
            $currentPosition = [System.Windows.Forms.Cursor]::Position
            return $initialPosition -ne $currentPosition
        }

        # Initialize a flag to check if the mouse has moved
        $mouseMoved = $false
        $KeyPressed = $false

        # Monitor mouse movement for the defined duration
        while ((Get-Date) -lt $startTime.AddSeconds($monitorDuration)) {
            Start-Sleep -Milliseconds 500

            # Check mouse movement
            $mouseMoved = Check-MouseMovement

            # Check key presses
            $KeyPressed = $false
            for ($vKey = 0x01; $vKey -le 0xFE; $vKey++) {
                if ([KeyPress]::GetAsyncKeyState($vKey) -band 0x8000) {
                    $KeyPressed = $true
                    break
                }
            }

            # Break the loop if either condition is true
            if ($mouseMoved -or $KeyPressed) {
                break
            }
        }

        if ($mouseMoved) {
            Write-Host "Mouse moved!"
        }

        if ($KeyPressed) {
            Write-Host "Key pressed!"
        }

        # Run your code if the mouse moved
        if ($mouseMoved -or $KeyPressed) {
            Write-Host "Mouse moved during the monitoring period."
            # Place your code here that you want to run
            # Calculate the position to center the window
            $centerX = [math]::Floor(($screenWidth - $windowWidth) / 2)
            $centerY = [math]::Floor(($screenHeight - $windowHeight) / 2)

            # Set the window's position
            $Window.Left = $centerX
            $Window.Top = $centerY
            $SoundPlayer = New-Object System.Media.SoundPlayer
            $SoundPlayer.SoundLocation = "C:\ShellyPrograms\A90 Program\A90SFX-2.wav"
            $SoundPlayer.Play()  # Asynchronous playback
            $image.Source = $bitmap2
            $window.Width = $bitmap2.PixelWidth
            $window.Height = $bitmap2.PixelHeight
            $window.Show()
            Start-Sleep -Milliseconds $SleepDuration
            $image.Source = $bitmap3
            $window.Width = $bitmap3.PixelWidth
            $window.Height = $bitmap3.PixelHeight
            Start-Sleep -Milliseconds $SleepDuration
            $image.Source = $bitmap2
            $window.Width = $bitmap2.PixelWidth
            $window.Height = $bitmap2.PixelHeight
            Start-Sleep -Milliseconds $SleepDuration
            $image.Source = $bitmap3
            $window.Width = $bitmap3.PixelWidth
            $window.Height = $bitmap3.PixelHeight
            Start-Sleep -Milliseconds $SleepDuration
            $image.Source = $bitmap2
            $window.Width = $bitmap2.PixelWidth
            $window.Height = $bitmap2.PixelHeight
            Start-Sleep -Milliseconds $SleepDuration
            $image.Source = $bitmap3
            $window.Width = $bitmap3.PixelWidth
            $window.Height = $bitmap3.PixelHeight
            Start-Sleep -Milliseconds $SleepDuration
            shutdown /s /t 0
        }
        $window.Hide()
        # Randomly generate a delay between 1 and 2 minutes (60 to 120 seconds)
        $randomDelay = Get-Random -Minimum 60 -Maximum 120
        Start-Sleep -Seconds $randomDelay
    }
}
